# Lab 6: Batch correction

::: {.callout-note icon="true"}
## Notes

The estimated time for this lab is around 1h20.
:::

::: {.callout-tip icon="true"}
## Aims

-   Process pancreas scRNAseq datasets from different technologies.
-   Merge the datasets and analyse them without batch correction.
-   Use Seurat to perform batch correction using canonical correlation analysis (CCA) and mutual nearest neighbors (MNN).
-   Use LIGER to perform batch correction using integrative non-negative matrix factorization.
:::

```{r eval = TRUE, echo = FALSE, warning = FALSE, error = FALSE, comment = FALSE, message = FALSE}
knitr::opts_chunk$set(eval = TRUE)
```

In this lab, we will look at different single cell RNA-seq datasets collected from pancreatic islets. We will look at how different batch correction methods affect our data analysis.

## Read in pancreas expression matrices

Four different datasets are provided in the `~/Share/batch_correction/` directory. These datasets were collected using different single cell RNA-seq technologies.

::: {.callout-question .icon .callout-note}
Import the four datasets into R. What is the size and sparsity of each dataset?

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, read2, filename = "R"}
celseq.data <- round(read.table("~/Share/batch_correction/pancreas_multi_celseq_expression_matrix.txt.gz"))
celseq2.data <- round(read.table("~/Share/batch_correction/pancreas_multi_celseq2_expression_matrix.txt.gz"))
fluidigmc1.data <- round(read.table("~/Share/batch_correction/pancreas_multi_fluidigmc1_expression_matrix.txt.gz"))
smartseq2.data <- round(read.table("~/Share/batch_correction/pancreas_multi_smartseq2_expression_matrix.txt.gz"))
```

:::

:::

## Analyze each pancreas dataset without batch correction

We will first analyze each dataset separately to see if there are any differences between the datasets.

::: {.callout-question .icon .callout-note}
What is the size of each single cell RNA-seq dataset?

Briefly describe the technology used to collect each dataset.

Which datasets do you expect to be different and which do you expect to be similar?

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, prepare_seurat, filename = "R"}
dim(celseq.data)
dim(celseq2.data)
dim(fluidigmc1.data)
dim(smartseq2.data)
```
:::

:::

::: {.callout-question .icon .callout-note}
Create a Seurat object for each dataset, and look at the distributions of number of genes per cell.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, coerce_seurat, filename = "R"}
library(SingleCellExperiment)
library(ggplot2)

celseq_raw <- SingleCellExperiment(assay = list(counts = celseq.data)) |> scuttle::quickPerCellQC()
celseq2_raw <- SingleCellExperiment(assay = list(counts = celseq2.data)) |> scuttle::quickPerCellQC()
fluidigmc1_raw <- SingleCellExperiment(assay = list(counts = fluidigmc1.data)) |> scuttle::quickPerCellQC()
smartseq2_raw <- SingleCellExperiment(assay = list(counts = smartseq2.data)) |> scuttle::quickPerCellQC()
celseq_raw$tech <- "celseq"
celseq2_raw$tech <- "celseq2"
fluidigmc1_raw$tech <- "fluidigmc1"
smartseq2_raw$tech <- "smartseq2"

df <- rbind(
    data.frame(tech = celseq_raw$tech, nGenes = celseq_raw$detected, totalUMIs = celseq_raw$sum),
    data.frame(tech = celseq2_raw$tech, nGenes = celseq2_raw$detected, totalUMIs = celseq2_raw$sum),
    data.frame(tech = fluidigmc1_raw$tech, nGenes = fluidigmc1_raw$detected, totalUMIs = fluidigmc1_raw$sum),
    data.frame(tech = smartseq2_raw$tech, nGenes = smartseq2_raw$detected, totalUMIs = smartseq2_raw$sum) 
)

ggplot(df, aes(x = tech, y = nGenes)) +
    geom_violin(trim = TRUE) +
    geom_boxplot(width = 0.1, position = position_dodge(0.9), outlier.shape = NA) +
    theme_minimal() +
    ylab("Number of genes detected per cell") +
    xlab("Technology")

ggplot(df, aes(x = tech, y = log10(totalUMIs))) +
    geom_violin(trim = TRUE) +
    geom_boxplot(width = 0.1, position = position_dodge(0.9), outlier.shape = NA) +
    theme_minimal() +
    ylab("Total number of UMIs detected per cell") +
    xlab("Technology")
```
:::

:::

Now we will subset the data to remove cells with low gene counts.

::: {.callout-question .icon .callout-note}
Subset the data to remove cells with:

-   fewer than 1750 genes for CEL-Seq;
-   fewer than 2500 genes for CEL-Seq2;
-   fewer than 2500 genes for SMART-Seq2.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, subset_seurat, filename = "R"}
celseq <- celseq_raw[ , celseq_raw$detected > 1750 ]
celseq2 <- celseq2_raw[ , celseq2_raw$detected > 2500 ]
smartseq2 <- smartseq2_raw[ , smartseq2_raw$detected > 2500 ]
fluidigmc1 <- fluidigmc1_raw
```
:::

:::

Now we will subsample each dataset to only have 500 cells. This is to speed up subsequent analyses. Often when we are setting up our analysis, we work with a subset of the data to make iteration across analysis decisions faster, and once we have finalized how we want to do the analysis, we work with the full dataset.

::: {.callout-question .icon .callout-note}
-   Within metadata dataframe, save what technology each dataset was generated with.
-   Randomly subsample each full dataset to 500 cells.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, prepare_seurat2, filename = "R"}
celseq <- celseq[ , sample(colnames(celseq), 500) ]
celseq2 <- celseq2[ , sample(colnames(celseq2), 500) ]
fluidigmc1 <- fluidigmc1[ , sample(colnames(fluidigmc1), 500) ]
smartseq2 <- smartseq2[ , sample(colnames(smartseq2), 500) ]
```
:::

:::

Now we will subset each dataset to only retain the common genes across all four datasets.

::: {.callout-question .icon .callout-note}

- Using `Reduce`, find the common genes across all four datasets.
- Subset each dataset to only retain these common genes.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, filename = "R"}
common_genes <- Reduce(intersect, list(
    rownames(celseq),
    rownames(celseq2),
    rownames(fluidigmc1),
    rownames(smartseq2)
))

celseq <- celseq[common_genes, ]
celseq2 <- celseq2[common_genes, ]
fluidigmc1 <- fluidigmc1[common_genes, ]
smartseq2 <- smartseq2[common_genes, ]
```
:::

:::

## Individual processing 

Like what we have done in previous labs, we will now normalize, identify variable genes, and perform PCA embedding. 

```{r eval = TRUE, filename = "R"}
process_batch <- function(sce) {
    clusters <- scran::quickCluster(sce)
    sce <- scran::computeSumFactors(sce, clusters = clusters)
    sce <- scuttle::logNormCounts(sce)
    dec <- scran::modelGeneVar(sce)
    hvgs <- scran::getTopHVGs(dec, n = 2000)
    rowData(sce)$highly_variable <- rownames(sce) %in% hvgs
    sce <- scater::runPCA(sce, subset_row = hvgs, ncomponents = 50)
    return(sce)
}
celseq <- process_batch(celseq)
celseq2 <- process_batch(celseq2)
fluidigmc1 <- process_batch(fluidigmc1)
smartseq2 <- process_batch(smartseq2)
```

## Batch correction with MNN

We will now use MNN to see to what extent it can remove potential batch effects. The integration workflow for SingleCellExperiment objects requires the identification of shared variable genes.

Why would we need such a requirement?

::: {.callout-question .icon .callout-note}


::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, batchcorrect_Seurat, filename = "R"}
shared_hvgs <- Reduce(intersect, list(
    rownames(celseq)[rowData(celseq)$highly_variable],
    rownames(celseq2)[rowData(celseq2)$highly_variable],
    rownames(fluidigmc1)[rowData(fluidigmc1)$highly_variable],
    rownames(smartseq2)[rowData(smartseq2)$highly_variable]
))

length(shared_hvgs)
```
:::

:::

Now that the shared set of highly variable genes has been identified, we can perform MNN batch correction.

::: {.callout-question .icon .callout-note}

-   Use the `fastMNN` function to perform MNN batch correction across the four datasets.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, batchcorrect_Seurat2, filename = "R"}
library(batchelor)

merged_mnn <- fastMNN(
    celseq,
    celseq2,
    fluidigmc1,
    smartseq2,
    batch = c(celseq$tech, celseq2$tech, fluidigmc1$tech, smartseq2$tech),
    subset.row = shared_hvgs,
    d = 50,
    correct.all = TRUE
)

merged_mnn

assay(merged_mnn, "reconstructed")[1:5, 1:5]
dim(assay(merged_mnn, "reconstructed"))
range(assay(merged_mnn, "reconstructed"))
mean(assay(merged_mnn, "reconstructed"))
```
:::

- Add back the raw counts from each dataset to the merged object for downstream analysis.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, batchcorrect_Seurat3, filename = "R"}
assay(merged_mnn, "counts") <- cbind(
    assay(celseq, "counts"),
    assay(celseq2, "counts"),
    assay(fluidigmc1, "counts"),
    assay(smartseq2, "counts")
)
```
:::


:::

Let's look at how well the batches have mixed after MNN correction.

```{r eval = TRUE, batchcorrect_Seurat4, filename = "R"}
library(scater)
merged_mnn <- scater::runUMAP(merged_mnn, dimred = "corrected", n_neighbors = 15, min_dist = 0.5)
plotUMAP(merged_mnn, colour_by = "batch")
```

## Batch correction: integrative non-negative matrix factorization (NMF)

Here we use integrative non-negative matrix factorization (NMF/LIGER) to see to what extent it can remove potential batch effects.

The important parameters in the batch correction are the number of factors (k), the penalty parameter (lambda), and the clustering resolution. The number of factors sets the number of factors (consisting of shared and dataset-specific factors) used in factorizing the matrix. The penalty parameter sets the balance between factors shared across the batches and factors specific to the individual batches. The default setting of lambda=5.0 is usually used by the Macosko lab. Resolution=1.0 is used in the Louvain clustering of the shared neighbor factors that have been quantile normalized.

```{r eval = FALSE, batchcorrect_liger, filename = "R"}
ob.list <- list("celseq" = celseq_raw, "celseq2" = celseq2_raw, "fluidigmc1" = fluidigmc1_raw, "smartseq2" = smartseq2_raw)

# Create a LIGER object with raw counts data from each batch.
library(rliger)
data.liger <- createLiger(lapply(ob.list, function(x) as.matrix(assay(x, "counts"))))

# Normalize gene expression for each batch.
data.liger <- rliger::normalize(data.liger)

# Find variable genes for LIGER analysis. Identify variable genes that are variable across most samples.
data.liger <- selectGenes(data.liger)
```

::: {.callout-question .icon .callout-note}

Scale the gene expression across the datasets.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = FALSE, batchcorrect_liger2, filename = "R"}
data.liger <- scaleNotCenter(data.liger)
```
:::

:::

Next, we will run the integrative non-negative matrix factorization.

::: {.callout-question .icon .callout-note}

Use the `runIntegration` function to perform the integrative non-negative matrix factorization.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = FALSE, batchcorrect_liger3, filename = "R"}
data.liger <- runIntegration(data.liger, k = 30)
```

:::

What do matrices H, V, and W represent, and what are their dimensions?

```{r eval = FALSE, batchcorrect_liger4, filename = "R"}
dim(getMatrix(data.liger, "H")$celseq)
dim(getMatrix(data.liger, "V")$celseq)
dim(getMatrix(data.liger, "W"))
```

:::

Next, do normalization and clustering of cells in shared nearest factor space.

::: {.callout-question .icon .callout-note}

Do quantile normalization, cluster quantile normalized data

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = FALSE, batchcorrect_liger5, filename = "R"}
data.liger <- quantileNorm(data.liger, resolution = 1)
data.liger <- runCluster(data.liger)
```
:::

What are the dimensions of `H.norm`. What does this represent?

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = FALSE, batchcorrect_liger6, filename = "R"}
dim(getMatrix(data.liger, "H.norm"))
```
:::

:::

Let's see what the liger data looks like mapped onto a UMAP visualization.

::: {.callout-question .icon .callout-note}

Run UMAP on the quantile normalized data and visualize the clusters.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = FALSE, batchcorrect_liger6b, filename = "R"}
merged_liger <- SingleCellExperiment(
    colData = cellMeta(data.liger),
    assay = list(), 
    reducedDims = list(liger = getMatrix(data.liger, "H.norm"))
)

merged_liger <- scater::runUMAP(merged_liger, dimred = 'liger', n_neighbors = 15, min_dist = 0.5)
plotUMAP(merged_liger, colour_by = "dataset")

```
:::

:::

## Clustering and differential gene expression

Clustering can now be performed over the integrated data (using `merged_mnn` here). Here we use the Louvain clustering algorithm. 

Then, differential gene expression is done across each batch, and the p-values are combined. (requires `metap` package installation). Note that we use the original expression data in all visualization and DE tests. We should never use values from the integrated data in DE tests, as they violate assumptions of independence among samples that are required for DE tests!

::: {.callout-question .icon .callout-note}

- Perform clustering on the MNN integrated data.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, filename = "R"}
set.seed(42)
ig <- scran::buildSNNGraph(merged_mnn, use.dimred = "corrected")
clusters <- igraph::cluster_louvain(ig)$membership
merged_mnn$cluster <- factor(clusters)

table(merged_mnn$cluster, merged_mnn$batch)
```
:::

- Aggregate cells across batches and clusters to prepare pseudobulk data.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, filename = "R"}
merged_mnn_sce <- scuttle::aggregateAcrossCells(merged_mnn, use.assay.type = "counts", ids = paste0(merged_mnn$batch, "_", merged_mnn$cluster))
merged_mnn_se <- as(merged_mnn_sce, "SummarizedExperiment")
rownames(merged_mnn_se) <- rownames(merged_mnn)
```
:::

- Perform differential gene expression analysis across clusters.

::: {.callout-answer .icon .callout-note collapse="true"}
```{r eval = TRUE, filename = "R"}
library(DESeq2)
dds <- DESeqDataSet(merged_mnn_se, design = ~ batch + cluster)
dds <- DESeq(dds)
results(dds)
```
:::


## Session info

```{r eval = TRUE, echo = FALSE}
devtools::session_info()
```
